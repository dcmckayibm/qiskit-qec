# -*- coding: utf-8 -*-

# This code is part of Qiskit.
#
# (C) Copyright IBM 2023.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

# pylint: disable=invalid-name

"""Creates a CodeCircuit object for a pre-existing circuit."""
import copy
import rustworkx as rx

from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator


class GenericCodeCircuit:
    """GenericCodeCircuit Class"""

    def __init__(self, circuits, ese_list, ese_info=None):
        """
        circuits (list, tuple or QuantumCircuit): `QuantumCircuit` or collection thereof.
        The output strings of these circuits should have the same format.
        ese_list: List of tuples, with each tuple containing a set of indices for the
        output strings (numbered right to left), such that the parity of the corresponding
        output bits should have a fixed value.
        """

        # store circuit in a dictionary with the index as the key
        if isinstance(circuits, (list, tuple, set)):
            self.circuit = {}
            for j, circuit in enumerate(circuits):
                self.circuit[j] = circuit
        else:
            self.circuit = {0: circuits}
        # choose the first to be the base circuit
        self.base = 0

        self.ese_list = ese_list
        self.ese_info = ese_info
        self._get_parities()

    def _get_ese_string(self, string, ese):
        """
        For the given string, determine the parities of all error sensitive events.
        """
        ese_string = ""
        for index in ese:
            ese_string += string[-1 - index]
        return ese_string

    def _get_parities(self):
        """
        Simulates circuit to determine what values the parities should ideally be
        for each circuit.
        """
        qasm_sim = AerSimulator()
        parities = {}
        for basis, qc in self.circuit.items():
            parities[basis] = []
            counts = qasm_sim.run(qc).result().get_counts()
            string = list(counts.keys())[0]
            for ese in self.ese_list:
                ese_string = self._get_ese_string(string, ese)
                parity = ese_string.count("1") % 2
                parities[basis].append(parity)
        self.parities = parities

    def string2nodes(self, string, **kwargs):
        """
        Args:
            string (string): Results string to convert.
            kwargs (dict): Additional keyword arguments.
                index (int): Index of circuit for which nodes are
                calculated.
        Returns:
            dict: List of nodes corresponding to to the non-trivial
            elements in the string.
        """
        index = kwargs.get("index")
        if index is None:
            index = self.base
        nodes = []
        for e, ese in enumerate(self.ese_list):
            ese_string = self._get_ese_string(string, ese)
            if ese_string.count("1") % 2 != self.parities[index][e]:
                if self.ese_info:
                    nodes.append(
                        {
                            "element": e,
                            "is_boundary": self.ese_info["is_boundary"],
                            "qubits": self.ese_info["qubits"],
                            "time": self.ese_info["time"],
                        }
                    )
                else:
                    nodes.append({"element": e, "is_boundary": False, "qubits": [], "time": 0})
        return nodes


def make_syndrome_graph_from_aer(code, shots=1):
    """
    Generates a graph and list of hyperedges for a given code by inserting single qubit
    Paulis into the base circuit for that code. Also supplied information regarding which
    edges where generated by which Pauli insertions.

    Args:
        code (CodeCircuit): Code for which the graph is to be made
        shots (int): Number of shots used in simulations.
    Returns:
        graph (PyGraph): Graph of the form used in `DecodingGraph`.
        hyperedges (list): List of hyperedges of the form used in `DecodingGraph`.
        hyperedge_errors (list): A list of the Pauli insertions that causes each hyperedge.
        These are specified by a tuple that specifies the type of Pauli and where it was
        inserted: (circuit depth, qreg index, qubit index, Pauli type).
        error_circuit (dict): Keys are the above tuples, and values are the corresponding
        circuits.
    """

    graph = rx.PyGraph(multigraph=False)
    hyperedges = []
    hyperedge_errors = []

    qc = code.circuit[code.base]
    blank_qc = QuantumCircuit()
    for qreg in qc.qregs:
        blank_qc.add_register(qreg)
    for creg in qc.cregs:
        blank_qc.add_register(creg)

    error_circuit = {}
    depth = len(qc)
    for j in range(depth):
        gate = qc.data[j][0].name
        qubits = qc.data[j][1]
        if gate not in ["measure", "reset", "barrier"]:
            for error in ["x", "y", "z"]:
                for qubit in qubits:
                    temp_qc = copy.deepcopy(blank_qc)
                    for qreg in qc.qregs:
                        if qubit in qreg:
                            break
                    temp_qc_name = (j, qc.qregs.index(qreg), qreg.index(qubit), error)
                    temp_qc.data = qc.data[0:j]
                    getattr(temp_qc, error)(qubit)
                    temp_qc.data += qc.data[j : depth + 1]
                    error_circuit[temp_qc_name] = temp_qc
        elif gate == "measure":
            pre_error = "x"
            for post_error in ["id", "x"]:
                for qubit in qubits:
                    temp_qc = copy.deepcopy(blank_qc)
                    for qreg in qc.qregs:
                        if qubit in qreg:
                            break
                    temp_qc_name = (j, qc.qregs.index(qreg), qreg.index(qubit), error)
                    temp_qc.data = qc.data[0:j]
                    getattr(temp_qc, pre_error)(qubit)
                    temp_qc.data.append(qc.data[j])
                    getattr(temp_qc, post_error)(qubit)
                    temp_qc.data += qc.data[j + 1 : depth + 1]
                    error_circuit[temp_qc_name] = temp_qc

    errors = []
    circuits = []
    for error, circuit in error_circuit.items():
        errors.append(error)
        circuits.append(circuit)

    result = AerSimulator().run(circuits, shots=shots).result()
    no_nodes = []
    for j, circuit in enumerate(circuits):
        for string in result.get_counts(j):
            nodes = code.string2nodes(string)
            for node in nodes:
                if node not in graph.nodes():
                    graph.add_node(node)
            hyperedge = {}
            for source in nodes:
                for target in nodes:
                    if target != source or (len(nodes) == 1):
                        n0 = graph.nodes().index(source)
                        n1 = graph.nodes().index(target)
                        edge = {"qubits": [], "weight": 1}
                        graph.add_edge(n0, n1, edge)
                        if (n1, n0) not in hyperedge:
                            hyperedge[n0, n1] = edge
            if hyperedge:
                if hyperedge not in hyperedges:
                    hyperedges.append(hyperedge)
                    hyperedge_errors.append([])
                k = hyperedges.index(hyperedge)
                if errors[j] not in hyperedge_errors[k]:
                    hyperedge_errors[k].append(errors[j])
            else:
                if errors[j] not in no_nodes:
                    no_nodes.append(errors[j])
    hyperedges.append({})
    hyperedge_errors.append(no_nodes)

    return graph, hyperedges, hyperedge_errors, error_circuit
